outside world does not need to know about THREE.js
besides vectors? those actually definitely need to be contained in Data
other than vectors, they don't need to know
And besides the VERY beginning, data should be passed around ONLY in vector form.

use private variables?

the only thing that really needs to be public is the mesh.

I'm the only one developing, so the logical solution is to just remember which ones are public functions, and which are private variables.

What options do we want for changing this?
We want to transform it, which requires changing the curve and geometry
We want to change the shape involved, which requires rebuilding the geometry
We want to change the color or wireframe, so changing the material and updating the mesh

I would prefer to keep all of these operations consistent, which would mean no
changing of variables without updating of THREE.js objects.
Is there ever a reason NOT to do this?
There really isn't, so that's what I'll do.

radius, segments, both require rebuilding shape and geometry
wireframe, color only require reassignment of material
curve changing requires updating of curve and geometry, done in transform function

remember that start and end aren't cloned in the init.
Actually, definitely should clone. Changing of vectors from another class through aliasing is the least OOP thing

problem: how do we remove a tube from the scene? We could make that the responsibility of the gl object.
only two options really: either gl takes the mesh from the tube, or tube receives the scene from the gl.
Can't pass function alone.

OH neat solution: have the destroy method return the mesh.
and for adding? just get the mesh.

can't prevent any class from calling methods on an object that I want to be destroyed.

Should I consolidate the materials? might save memory, but they wouldn't be updated all that often.

should I move args to a property so it doesn't need to be passed in every time?
No, that would mean an inconsistent state. Also, if they don't need to be changed, why would this function be called.
args is {radius, segments}

No reason to pass THREE.Colors into GraphObjects, they can handle it themselves with color arrays.
real question is still material consolidation.

should a tube accept two points or a Line object?

We could ID vectors. But that might cause weird issues with removal
How am I going to remove lines from the data list?

using splice of course. But will it always be safe to assume parallelism?
and then when I request the removal of a line, I have to find the points it contains, remove those too, and update the Graph arrays.

How would it be done with ID's?

Or could use an array of objects that contain both the tubes and lines, or both the points and spheres.
but where would that be held? and would that require changes to the existing classes?

Well how should the points be transformed exactly?

Old system was to have the points in the array be aliased to the points in the lines. That was quite efficient.
And it is the most efficient way to update continuously. it's also really fucking confusing.
that kind of system might require a rework of the GraphObjects.
Well I'm DEFINITELY going to use this system because it is so much more efficient.
What should the systems around it look like?

OPtions:
array of vectors aliased to array of Line objects. Both passed to graph, cloned to enter the Tube and Sphere objects.
array of Sphere objects whose vectors are aliased to the vectors in the Line objects in the Tube objects?
	this one requires temporary inconsistent states, as the geometries would have to be rebuilt AFTER the aliasing changes.
	would have to remember to do that, and to do it correctly.
	If we did this, we would have to rebuild some classes to make them safe for aliasing, and I don't want to do that right now.

INSTEAD: we keep the aliasing separate from the THREE.js objects, and make Data handle that.
will have to alias the vectors into the vector components of each line. Because the lines are really just containers for those vectors,
won't break validity, only breaks encapsulation a little.

this doesn't significantly impact the animation performance because the real cost of the updating of GraphObjects
is the reconstruction of the geometries, which would have to happen even if we weren't aliasing.

The real cost of the building of the data is the continuous projection, which IS significantly helped by aliasing.

Graph objects shouldn't have conditional assignment to property, should have both conditional assignment and conditional updating, when possible
Actually, the updatePath methods can't really change, and the material changing is fast enough.

I DO NOT NEED TO ASSIGN TO NULL BEFORE A SECOND ASSIGNMENT. WILL LOSE REFERENCE ANYWAYS

When do I really need to know the length of a line? never, I think. So we can keep that as a method, but not a property.

// Stores FOUR-dimensional coordinates, never THREE-dimensional.
// How do we want checking for containing of points to work? We would want to know WHICH vector matched,
// probably all in one step. We could also just pass a single vector to alias, which would figure out which one to replace.
// Doesnt need to find MaxDistance, that would be done through points.

// How would Data really use these? It goes through the list of points, and for each point,
// checks whether it is contained in any line in lines. That would only happen during the initialization of the data.
// That's not as important. What would we want to happen when another line is added? we check whether either point
// is the same as any other point in the list. If not, we add the new points.
// If both are unique, totally new line created and added.
// if only one unique, we make a new line, but alias the non-unique one. Neither requires the containsPoint methods.

// What if we want to remove a line? we need to check whether either point overlaps with any others.
// After that, if neither overlaps, we destroy everything.
// If both overlap, we destroy the line, but DON'T call destroy() on it.
// If only one overlaps, we have to specify its destruction, then nullify the line.

// On ANY identity change to points or lines, ppoints and plines must be updated.
// Quick clarification: NO VECTORS ARE ALIASED between the normal and p versions.
// vectors ARE ALIASED between ppoints and plines

// How is that done?
// MOST EFFICIENT WAY: assuming that the arrays of lines and plines, points and ppoints are absolutely parallel,
// down to the v1 and v2 of each line, we can just call exactly the same methods whenever points or lines are changed.
// That's what would be done anyways.
// This means that the starting arrays must be completely parallel, and then everything else should follow cleanly
// from there. ACTUALLY YOU KNOW WHAT: THE REALLY SAFE WAY TO DO THIS WOULD BE TO BUILD AN ENCAPSULATING PARALLEL
// ARRAYS OBJECT. but that would be difficult. Which operations would be parallel, and which wouldn't?

// Yeah that would be hard. Imagine trying to place an aliased pair in the normal list. The parallel array would have to
// clone both parts, but keep the aliased connection between them, which would be impossible. It would have to know that they
// were aliased together, which seems like a break of specialization.

// identity tested with ==, congruency with .equals

/*
I do need the ppoint and pline system right? What would my alternatives be?
Well what do I really need to pass in to Graph? I could perspectify every point individually, but that would require
either mutation or the creation of a new variable every time.

OR What if I kept just one vector variable and one line variable that mutated to match the perspective versions
of each vector and line?
I could send that one over to mutate the corresponding Tubes and Spheres based on index.
BIG QUESTION: Is there a higher cost? YES. Each line would have to be perspectified individually, so that's out.

I HAVE TO UPDATE PPOINTS, AND LET THOSE CHANGES ALIAS SOOOMEEHOOOW
Yeeaahh, ppoints and plines seem like hte best option, unfortunately.
so yeaah, I'll just construct them properly on initialization and have to remember to update them in parallel all the time.

I would always prefer to mutate other variables, which means keeping a

Should I integrate the Lines with the Tubes? that would mean making them store a curve instead of two vectors.
That would have the benefit of not having to pass a new array to Graph every time, and instead having the changes alias into the GraphObjects.
Then, Graph could just recreate the geometry for every object, without also copying each new vector
into the curves of the GraphObjects. That's actually kinda like Mesh.assignGeometry(), which I was comfortable and even happy with.
Yeah. The ACCEPTED usage of meshes is to pull
Wait no that's different. That maybe have been a mixture of scopes, but it wasn't aliasing.

new beef with oop:
	according to oop, every object should be responsible for its own tasks.
	But then that really quickly becomes an issue. For instance, the Line object. Clearly, we would have to either pull
	out its curve, or give it all the information to make a geometry. The second option would be bullshit,
	so we have to pull the curve. The only way to do it would be to NOT wrap the curve in another object.
	OR, wrap the curve in the same object that wraps the geometries.
	In that case, we have to make extraneous objects for the normal points and lines, which is FUCKING INEFFICIENT.
	YES, OOP IS FUCKING INEFFIIICIIIIEEENT!

	Is it?

	You can pass objects around in OOP
	the thing that has the information does the work
	supposedly resistant to changes in implementation, i.e. the type of a property
	I guess that can't be true for inside the class. inside the class, you should always know everything about the properties.
	Outside the class, you shouldn't grab values, you should tell the class to operate on them?

	oop is never a panacea
	FP is never a panacea
	immutability is never a panacea

ppoints and plines ARE UNAVOIDABLE
the ways I deal with them are not, I don't think
graph, data, and gl all make a lot of sense as classes.
Lines make sense as the unit of trade within Data, and GraphObjects make sense for Graph.
aliasing makes sense for efficiency, and I'm going for efficiency. In that case, would I use the data structure paradigm?
Am I just defending bad code?

I should read about data-oriented design

and maybe as practice, I should maximize the efficiency of this website.

During animation, what are the stages?

use the current rotation to transform every point in points
perspective them into ppoints
tell the geometries to redraw

that's about as simple and efficient as I'll get.
should I do a data-oriented approach to GraphObjects? Not yet.

The real issue is the moment methods of Data, and the aliasing.
aliasing should NOT be the default.
Data moment methods should be split up more.
parallel arrays class? or useless?

oh okay the "correct" way to make lines without introducing invalid states would be to use builders,
but those are a waste of time for this size.

okay, I realized I can alias most of the stuff in GraphObjects to save a shitload of space.
Now the problem is updating those aliased things without changing identity.
Most importantly, I need to update an external shape to use a different radius or segments without reassigning it.

I could do that by making a new shape, disposing of the holes of the old shape, and reassigning the holes of the new shape.
OH NO SOLUTION: make a super simple class wrapper around the shape, so we can reassign the shape INSIDE the wrapper without changing the identity of the wrapper.

it's not sufficient to just reassign the mesh positions, they have to be copied in. For some reason, they are COMPLETELY immune
to assignment. The = operator does nothing to them. Do not understand how that is possible.
AH okay. Object.defineProperty allows you to customize how properties work, including making them immutable.
You can also kinda make them private!

I MADE A CHANGE TO THREE.JS FOR CONVENIENCE! REMEMBER THAT THAT IS VERY DANGEROUS!
