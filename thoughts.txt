center of projection must always be at origin to make things easy. Then put camera vector space at 1 unit in the w direction away from origin, and put 4d shape with the closest point to the origin in the w-direction lying on the vector space.

Now, the projection of any point (a, b, c, d) from the shape onto the space is (a/d, b/c, c/d, 1)
d must always be >= 1

one big cube taking up most of space on right, bar div on left retractable with x

what kinds of classes / functions do I need?

Graph class for entire graph, keep all graph data contained, manipulate from outside only with functions, static
helper matrix functions in Matrix class (don't use libraries, unnecessary length), also static
settings functions? can stay in settings functions object, nicely contained, easy access with string names (Settings class?)
How do we do the point movements? can it be done better than last time? experiment.

options: class syntax style
        object / prototype syntax style
        constructor syntax style

favor object style, only one object needed, class with static methods unnecessary.
figure out a way around dumb matrices

remember the issue you had with the trackball controls zoom. Don't let that happen again.

controls need to be updated all the time

when  a function is passed into requestAnimationFrame, it will not be called from the context of the class it belongs to.
It will be called as its own function, and will therefore not have normal access to the objects properties.
It's "this" becomes the global object, the window.

When you use geometry.applyMatrix(), it doesn't apply the matrix the way you think it would.
every geometry is actually only stored in positions RELATIVE to their "position", and only that position is actually transformed.
I have to find a way to transform the actual vertices.
SOLUTION: Matrix multiplication is distributive, and the actual position of each vertex is (position_v + vertex_v)
With 4d transformation matrix A, I want A * (actual position) or A * (position_v + vertex_v)
OR
A * position_v + A * vertex_v
which I can do by just using the normal mesh.geometry.applyMatrix, and then mesh.position.applyMatrix4

When a vector is used to build a geometry, changing the vector WILL NOT change the geometry.

You cannot pass in an empty geometry to a mesh.

TO FREE UP MEMORY: set the value of a var variable to null, and allow the current function to end.
The variable will become eligible for garbage collection, and even without that it will take up only a tiny amount of space.

NEW VECTOR SYSTEM:
We have lines, points, perspective_lines, and perspective_points.
every vector in lines is really an alias to a vector in points, saving memory.
Same with the perspective versions.

When a new transformation is applied, it is applied ONLY to the vectors in points.
The points are then passed through the perspectify function, which copies the data into the perspective_points function.
This will also, of course, update the perspective_lines array.
At this point, the perspective_lines can be used to build new geometries and update the meshes.

COMMENTS FROM GRAPH.JS:
During program execution, the real 4d points and lines are kept in vector form
In the plot stage, the vector_lines and points are perspectified, and the new perspetive points stored in a list
the vectors in that list are cloned into the proper meshes, and then the perspective list is destroyed completely

shit. The animate stage will have to be very very different

during the animate loop, what happens?
the actual 4d vectors need to be transformed with the current rotation
then they need to be perspectified (very quick actually), and passed into the meshes somehow. HOW?
can I just update their geometries? that was the old approach, and I think it's best. make new geometry each time, delete the old.

Oh. I would have had to do that anyways, because I'm transforming 4d vectors, not 3d.

Perspectify: pretend that the point with the lowest w-value is actually at w=1, with the rest of the shape moved
				accordingly. Now, for every point, divide the x, y, and z-values by the point's w-value

should I store vector_lines AND vector_points? I think so.
perspective lines and points are NEVER stored. There is no point in storing them, because we only transform the others.

NEW STRUCTURE:
the only thing we change is the points lists.
The lines lists actually only contain references to the vectors in the points lists, so we only need to change those.
This means that we need to build the points lists, then use a connections matrix to build the lines lists.

THEN we copy the vectors into a perspective points list, and reference those in a perspective lines list.

ORDER OF IMPLEMENTATION:
get connections array
make the function to build the vector_lines based off the vector_points
test that transforming the vector_points transforms the vector_lines

how should plot work now?
make a new function that does the geometry creation, so it can be used in animate

Also, for efficiency,  extrusion geometries should only ever use LambertMaterials
and sphere geometries should only ever use PhongMaterials. Need to recognize which is which in animate().

function takes in vector_lines array, produces aliased vector_points arrays
also goes through original array, and if any vectors are the same, those are aliased to each other.


dat_gui:

uses the gui to change the values in the give object.

if they've never visited the site before, the help/about button should just softly pulse.
It should lead to another page, which can explain in detail and expand beyond the window.

course:
get the gui working for manual rotations, animations, etc.
Get the points customizer working
add node, use cookies to get a starting help window that can also be accessed from the main display.
ensure compatibility with other browsers
get mobile working and nice
add higher dimensions


selective hide and show for the panels might be the best option. No, just have the settings div scroll.
I want the user to have everything available, all the time, especially considering I almost have enough space.
problem: will have to manually add buttons to the gui's for manual rotations

how to display plotted points and get them back for deletion?
really don't want to just parse backwards.
can store them in an initial list, but that takes space.

animate CAN ONLY RUN if render is also running. critical.
options for interface: animateAndRender or Render, not just Animate.

FUCK there's a memory leak when you press reset.
FOR THE FUTURE: WRITE UNIT TESTS. FUCK THOSE COULD HAVE BEEN SO HANDY
ALSO MORE ISOLATION, MODIFYING GRAPH VARIABLES DIRECTLY IS BAD

YEP, the slowdown is definitely coming from restarting the renderloop. I think its causing multiple copies to run at the same time.

SO: NEVER EVER stop animateandrender and then immediately start again. If there is no delay, two different function loops will be started, and cause a memory leak.

THE PERSPECTIVE PROJECTION IS WRONG
it doesn't make any sense to shift the whole thing over, that means the addition of one new point causes all the others to change.
Projection should be onto space w=1 with center of projection at origin, yes, but the space should never move, and neither should the object.
just divide by w-distance from plane. If the object's w is greater than 0, divide by w.
if less,

outside world does not need to know about THREE.js
besides vectors? those actually definitely need to be contained in Data
other than vectors, they don't need to know
And besides the VERY beginning, data should be passed around ONLY in vector form.

use private variables?

the only thing that really needs to be public is the mesh.

I'm the only one developing, so the logical solution is to just remember which ones are public functions, and which are private variables.

What options do we want for changing this?
We want to transform it, which requires changing the curve and geometry
We want to change the shape involved, which requires rebuilding the geometry
We want to change the color or wireframe, so changing the material and updating the mesh

I would prefer to keep all of these operations consistent, which would mean no
changing of variables without updating of THREE.js objects.
Is there ever a reason NOT to do this?
There really isn't, so that's what I'll do.

radius, segments, both require rebuilding shape and geometry
wireframe, color only require reassignment of material
curve changing requires updating of curve and geometry, done in transform function

remember that start and end aren't cloned in the init.
Actually, definitely should clone. Changing of vectors from another class through aliasing is the least OOP thing

problem: how do we remove a tube from the scene? We could make that the responsibility of the gl object.
only two options really: either gl takes the mesh from the tube, or tube receives the scene from the gl.
Can't pass function alone.

OH neat solution: have the destroy method return the mesh.
and for adding? just get the mesh.

can't prevent any class from calling methods on an object that I want to be destroyed.

Should I consolidate the materials? might save memory, but they wouldn't be updated all that often.

should I move args to a property so it doesn't need to be passed in every time?
No, that would mean an inconsistent state. Also, if they don't need to be changed, why would this function be called.
args is {radius, segments}

No reason to pass THREE.Colors into GraphObjects, they can handle it themselves with color arrays.
real question is still material consolidation.

should a tube accept two points or a Line object?

We could ID vectors. But that might cause weird issues with removal
How am I going to remove lines from the data list?

using splice of course. But will it always be safe to assume parallelism?
and then when I request the removal of a line, I have to find the points it contains, remove those too, and update the Graph arrays.

How would it be done with ID's?

Or could use an array of objects that contain both the tubes and lines, or both the points and spheres.
but where would that be held? and would that require changes to the existing classes?

Well how should the points be transformed exactly?

Old system was to have the points in the array be aliased to the points in the lines. That was quite efficient.
And it is the most efficient way to update continuously. it's also really fucking confusing.
that kind of system might require a rework of the GraphObjects.
Well I'm DEFINITELY going to use this system because it is so much more efficient.
What should the systems around it look like?

OPtions:
array of vectors aliased to array of Line objects. Both passed to graph, cloned to enter the Tube and Sphere objects.
array of Sphere objects whose vectors are aliased to the vectors in the Line objects in the Tube objects?
	this one requires temporary inconsistent states, as the geometries would have to be rebuilt AFTER the aliasing changes.
	would have to remember to do that, and to do it correctly.
	If we did this, we would have to rebuild some classes to make them safe for aliasing, and I don't want to do that right now.

INSTEAD: we keep the aliasing separate from the THREE.js objects, and make Data handle that.
will have to alias the vectors into the vector components of each line. Because the lines are really just containers for those vectors,
won't break validity, only breaks encapsulation a little.

this doesn't significantly impact the animation performance because the real cost of the updating of GraphObjects
is the reconstruction of the geometries, which would have to happen even if we weren't aliasing.

The real cost of the building of the data is the continuous projection, which IS significantly helped by aliasing.

Graph objects shouldn't have conditional assignment to property, should have both conditional assignment and conditional updating, when possible
Actually, the updatePath methods can't really change, and the material changing is fast enough.

I DO NOT NEED TO ASSIGN TO NULL BEFORE A SECOND ASSIGNMENT. WILL LOSE REFERENCE ANYWAYS

When do I really need to know the length of a line? never, I think. So we can keep that as a method, but not a property.

// Stores FOUR-dimensional coordinates, never THREE-dimensional.
// How do we want checking for containing of points to work? We would want to know WHICH vector matched,
// probably all in one step. We could also just pass a single vector to alias, which would figure out which one to replace.
// Doesnt need to find MaxDistance, that would be done through points.

// How would Data really use these? It goes through the list of points, and for each point,
// checks whether it is contained in any line in lines. That would only happen during the initialization of the data.
// That's not as important. What would we want to happen when another line is added? we check whether either point
// is the same as any other point in the list. If not, we add the new points.
// If both are unique, totally new line created and added.
// if only one unique, we make a new line, but alias the non-unique one. Neither requires the containsPoint methods.

// What if we want to remove a line? we need to check whether either point overlaps with any others.
// After that, if neither overlaps, we destroy everything.
// If both overlap, we destroy the line, but DON'T call destroy() on it.
// If only one overlaps, we have to specify its destruction, then nullify the line.

// On ANY identity change to points or lines, ppoints and plines must be updated.
// Quick clarification: NO VECTORS ARE ALIASED between the normal and p versions.
// vectores ARE ALIASED between ppoints and plines

// How is that done?
// MOST EFFICIENT WAY: assuming that the arrays of lines and plines, points and ppoints are absolutely parallel,
// down to the v1 and v2 of each line, we can just call exactly the same methods whenever points or lines are changed.
// That's what would be done anyways.
// This means that the starting arrays must be completely parallel, and then everything else should follow cleanly
// from there. ACTUALLY YOU KNOW WHAT: THE REALLY SAFE WAY TO DO THIS WOULD BE TO BUILD AN ENCAPSULATING PARALLEL
// ARRAYS OBJECT. but that would be difficult. Which operations would be parallel, and which wouldn't?

// Yeah that would be hard. Imagine trying to place an aliased pair in the normal list. The parallel array would have to
// clone both parts, but keep the aliased connection between them, which would be impossible. It would have to know that they
// were aliased together, which seems like a break of specialization.

// identity tested with ==, congruency with .equals

/*
I do need the ppoint and pline system right? What would my alternatives be?
Well what do I really need to pass in to Graph? I could perspectify every point individually, but that would require
either mutation or the creation of a new variable every time.

OR What if I kept just one vector variable and one line variable that mutated to match the perspective versions
of each vector and line?
I could send that one over to mutate the corresponding Tubes and Spheres based on index.
BIG QUESTION: Is there a higher cost? YES. Each line would have to be perspectified individually, so that's out.

I HAVE TO UPDATE PPOINTS, AND LET THOSE CHANGES ALIAS SOOOMEEHOOOW
Yeeaahh, ppoints and plines seem like hte best option, unfortunately.
so yeaah, I'll just construct them properly on initialization and have to remember to update them in parallel all the time.

I would always prefer to mutate other variables, which means keeping a

Should I integrate the Lines with the Tubes? that would mean making them store a curve instead of two vectors.
That would have the benefit of not having to pass a new array to Graph every time, and instead having the changes alias into the GraphObjects.
Then, Graph could just recreate the geometry for every object, without also copying each new vector
into the curves of the GraphObjects. That's actually kinda like Mesh.assignGeometry(), which I was comfortable and even happy with.
Yeah. The ACCEPTED usage of meshes is to pull
Wait no that's different. That maybe have been a mixture of scopes, but it wasn't aliasing.
